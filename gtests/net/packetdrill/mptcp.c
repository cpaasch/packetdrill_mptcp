/**
 * Authors: Arnaud Schils
 */

#include "mptcp.h"
#include "packet_to_string.h"

//#include "mptcp_sha1.h"


void init_mp_state()
{
	mp_state.packetdrill_key_set = false;
	mp_state.kernel_key_set = false;
	queue_init(&mp_state.vars_queue);
	queue_init_val(&mp_state.vals_queue);
	mp_state.vars = NULL; //Init hashmap
	mp_state.last_packetdrill_addr_id = 0;
	mp_state.idsn = UNDEFINED;
	mp_state.remote_idsn = UNDEFINED;
	mp_state.remote_ssn = 0;
	mp_state.remote_last_pkt_length = 0;
//	mp_state.last_dsn_rcvd = 0;
}

void free_mp_state(){
	free_var_queue();
	free_val_queue();
	free_vars();
	free_flows();
}

/**
 * Remember mptcp connection key generated by packetdrill. This key is needed
 * during the entire mptcp connection and is common among all mptcp subflows.
 */
void set_packetdrill_key(u64 sender_key)
{
	mp_state.packetdrill_key = sender_key;
	mp_state.packetdrill_key_set = true;
}

/**
 * Remember mptcp connection key generated by kernel. This key is needed
 * during the entire mptcp connection and is common among all mptcp subflows.
 */
void set_kernel_key(u64 receiver_key)
{
    mp_state.kernel_key = receiver_key;
    mp_state.kernel_key_set = true;
}

/* var_queue functions */

/**
 * Insert a COPY of name char* in mp_state.vars_queue.
 * Error is returned if queue is full.
 *
 */
int enqueue_var(char *name)
{
	unsigned name_length = strlen(name);
	char *new_el = malloc(sizeof(char)*name_length);
	memcpy(new_el, name, name_length);
	int full_err = queue_enqueue(&mp_state.vars_queue, new_el);
	return full_err;
}

//Caller should free
int dequeue_var(char **name){
	int empty_err = queue_dequeue(&mp_state.vars_queue, (void**)name);
	return empty_err;
}

//Free all variables names (char*) in vars_queue
void free_var_queue()
{
	queue_free(&mp_state.vars_queue);
}

//Free all added values in vals_queue
void free_val_queue()
{
	queue_free_val(&mp_state.vals_queue);
}

/* hashmap functions */

void save_mp_var_name(char *name, struct mp_var *var)
{
	unsigned name_length = strlen(name);
	var->name = malloc(sizeof(char)*(name_length+1));
	memcpy(var->name, name, (name_length+1)); //+1 to copy '/0' too
}

/**
 *
 * Save a variable <name, value> in variables hashmap.
 * Where value is of u64 type key.
 *
 * Key memory location should stay valid, name is copied.
 *
 */
void add_mp_var_key(char *name, u64 *key)
{
	struct mp_var *var = malloc(sizeof(struct mp_var));
	save_mp_var_name(name, var);
	var->value = key;
	var->mptcp_subtype = MP_CAPABLE_SUBTYPE;
	var->mp_capable_info.script_defined = false;
	add_mp_var(var);
}

/**
 * Save a variable <name, value> in variables hashmap.
 * Value is copied in a newly allocated pointer and will be freed when
 * free_vars function will be executed.
 *
 */
void add_mp_var_script_defined(char *name, void *value, u32 length)
{
	struct mp_var *var = malloc(sizeof(struct mp_var));
	save_mp_var_name(name, var);
	var->value = malloc(length);
	memcpy(var->value, value, length);
	var->mptcp_subtype = MP_CAPABLE_SUBTYPE;
	var->mp_capable_info.script_defined = true;
	add_mp_var(var);
}

/**
 * Add var to the variable hashmap.
 */
void add_mp_var(struct mp_var *var)
{
	HASH_ADD_KEYPTR(hh, mp_state.vars, var->name, strlen(var->name), var);
}

/**
 * Search in the hashmap for the value of the variable of name "name" and
 * return both variable - value (mp_var struct).
 * NULL is returned if not found
 */
struct mp_var *find_mp_var(char *name)
{
    struct mp_var *found;
    HASH_FIND_STR(mp_state.vars, name, found);
    return found;
}

/**
 * Gives next mptcp key value needed to insert variable values while processing
 * the packets.
 */
u64 *find_next_key(){
	char *var_name;
	if(dequeue_var(&var_name) || !var_name){
		return NULL;
	}

	struct mp_var *var = find_mp_var(var_name);
	free(var_name);
/*
	if(!var || var->mptcp_subtype != MP_CAPABLE_SUBTYPE){
		return NULL;
	}*/
	return (u64*)var->value;
}

/**
 * Iterate through hashmap, free mp_var structs and mp_var->name.
 * Value is not freed for KEY type, since values come from stack.
 */
void free_vars()
{
	struct mp_var *next, *var;
	var = mp_state.vars;

	while(var){
		next = var->hh.next;
		free(var->name);
		if(var->mptcp_subtype == MP_CAPABLE_SUBTYPE){
			if(var->mp_capable_info.script_defined)
				free(var->value);
		}
		free(var);
		var = next;
	}
}

/**
 * Returns the next value entered in script (enqueud)
 */
u64 find_next_value(){
	u64 val;
	if(queue_dequeue_val(&mp_state.vals_queue, &val))
		return STATUS_ERR;
	return val;
}

/**
 * @pre inbound packet should be the first packet of a three-way handshake
 * mp_join initiated by packetdrill (thus an inbound mp_join syn packet).
 *
 * @post
 * - Create a new subflow structure containing all available information at this
 * time (src_ip, dst_ip, src_port, dst_port, packetdrill_rand_nbr,
 * packetdrill_addr_id). kernel_addr_id and kernel_rand_nbr should be set when
 * receiving syn+ack with mp_join mptcp option from kernel.
 *
 * - last_packetdrill_addr_id is incremented.
 */
struct mp_subflow *new_subflow_inbound(struct packet *inbound_packet)
{

	struct mp_subflow *subflow = malloc(sizeof(struct mp_subflow));

	if(inbound_packet->ipv4){
		ip_from_ipv4(&inbound_packet->ipv4->src_ip, &subflow->src_ip);
		ip_from_ipv4(&inbound_packet->ipv4->dst_ip, &subflow->dst_ip);
	}

	else if(inbound_packet->ipv6){
		ip_from_ipv6(&inbound_packet->ipv6->src_ip, &subflow->src_ip);
		ip_from_ipv6(&inbound_packet->ipv6->dst_ip, &subflow->dst_ip );
	}

	else{
		return NULL;
	}

	subflow->src_port =	ntohs(inbound_packet->tcp->src_port);
	subflow->dst_port = ntohs(inbound_packet->tcp->dst_port);
	subflow->packetdrill_rand_nbr =	generate_32();
	subflow->packetdrill_addr_id = mp_state.last_packetdrill_addr_id;
	mp_state.last_packetdrill_addr_id++;
	subflow->ssn = 1; // =1 because it initialized at third ack
//	subflow->state = UNDEFINED;  // TODO to define it and change the state after
	subflow->next = mp_state.subflows;
	mp_state.subflows = subflow;

	return subflow;
}

struct mp_subflow *new_subflow_outbound(struct packet *outbound_packet)
{

	struct mp_subflow *subflow = malloc(sizeof(struct mp_subflow));
	struct tcp_option *mp_join_syn =
			get_tcp_option(outbound_packet, TCPOPT_MPTCP);

	if(!mp_join_syn)
		return NULL;

	if(outbound_packet->ipv4){
		ip_from_ipv4(&outbound_packet->ipv4->dst_ip, &subflow->src_ip);
		ip_from_ipv4(&outbound_packet->ipv4->src_ip, &subflow->dst_ip);
	}

	else if(outbound_packet->ipv6){
		ip_from_ipv6(&outbound_packet->ipv6->dst_ip, &subflow->src_ip);
		ip_from_ipv6(&outbound_packet->ipv6->src_ip, &subflow->dst_ip);
	}

	else{
		return NULL;
	}

	subflow->src_port =	ntohs(outbound_packet->tcp->dst_port);
	subflow->dst_port = ntohs(outbound_packet->tcp->src_port);
	subflow->kernel_rand_nbr =
			mp_join_syn->data.mp_join.syn.no_ack.sender_random_number;
	subflow->kernel_addr_id =
			mp_join_syn->data.mp_join.syn.address_id;
	subflow->ssn = 0;
	subflow->next = mp_state.subflows;
	mp_state.subflows = subflow;

	return subflow;
}

/**
 * Return the first subflow S of mp_state.subflows for which match(packet, S)
 * returns true.
 */
struct mp_subflow *find_matching_subflow(struct packet *packet,
		bool (*match)(struct mp_subflow*, struct packet*))
{
	struct mp_subflow *subflow = mp_state.subflows;
	while(subflow){
		if((*match)(subflow, packet)){
			return subflow;
		}
		subflow = subflow->next;
	}
	return NULL;
}

static bool does_subflow_match_outbound_packet(struct mp_subflow *subflow,
		struct packet *outbound_packet){
	return subflow->dst_port == ntohs(outbound_packet->tcp->src_port) &&
			subflow->src_port == ntohs(outbound_packet->tcp->dst_port);
}

struct mp_subflow *find_subflow_matching_outbound_packet(
		struct packet *outbound_packet)
{
	return find_matching_subflow(outbound_packet, does_subflow_match_outbound_packet);
}

static bool does_subflow_match_inbound_packet(struct mp_subflow *subflow,
		struct packet *inbound_packet){
	return subflow->dst_port == ntohs(inbound_packet->tcp->dst_port) &&
			subflow->src_port == ntohs(inbound_packet->tcp->src_port);
}

struct mp_subflow *find_subflow_matching_inbound_packet(
		struct packet *inbound_packet)
{
	return find_matching_subflow(inbound_packet, does_subflow_match_inbound_packet);
}

struct mp_subflow *find_subflow_matching_socket(struct socket *socket){
	struct mp_subflow *subflow = mp_state.subflows;
	while(subflow){
		if(subflow->dst_port == socket->live.remote.port &&
				subflow->src_port == socket->live.local.port){
			return subflow;
		}
		subflow = subflow->next;
	}
	return NULL;
}

/**
 * Free all mptcp subflows struct being a member of mp_state.subflows list.
 */
void free_flows(){
	struct mp_subflow *subflow = mp_state.subflows;
	struct mp_subflow *temp;
	while(subflow){
		temp = subflow->next;
		free(subflow);
		subflow = temp;
	}
}

/**
 * Generate a mptcp packetdrill side key and save it for later reference in
 * the script.
 *
 */
int mptcp_gen_key()
{

	//Retrieve variable name parsed by bison.
	char *snd_var_name;
	if(queue_front(&mp_state.vars_queue, (void**)&snd_var_name))
		return STATUS_ERR;

	//Is that var has already a value assigned in the script by user, or should
	//we generate a mptcp key ourselves?
	struct mp_var *snd_var = find_mp_var(snd_var_name);

	if(snd_var && snd_var->mptcp_subtype == MP_CAPABLE_SUBTYPE &&
			snd_var->mp_capable_info.script_defined)
		set_packetdrill_key(*(u64*)snd_var->value);

	//First inbound mp_capable, generate new key
	//and save corresponding variable
	if(!mp_state.packetdrill_key_set){
		seed_generator();
		u64 key = rand_64();
		set_packetdrill_key(key);
		add_mp_var_key(snd_var_name, &mp_state.packetdrill_key);
	}

	return STATUS_OK;
}

/**
 * Insert key field value of mp_capable_syn mptcp option according to variable
 * specified in user script.
 *
 */
int mptcp_set_mp_cap_syn_key(struct tcp_option *tcp_opt)
{
	u64 *key = find_next_key();
	if(!key)
		return STATUS_ERR;
	tcp_opt->data.mp_capable.syn.key = *key;
	return STATUS_OK;
}

/**
 * Insert keys fields values of mp_capable mptcp option according to variables
 * specified in user script.
 */
int mptcp_set_mp_cap_keys(struct tcp_option *tcp_opt)
{
	u64 *key = find_next_key();
	if(!key)
		return STATUS_ERR;
	tcp_opt->data.mp_capable.no_syn.sender_key = *key;

	key = find_next_key();
	if(!key)
		return STATUS_ERR;
	tcp_opt->data.mp_capable.no_syn.receiver_key = *key;
	return STATUS_OK;
}

/**
 * Extract mptcp connection informations from mptcp packets sent by kernel.
 * (For example kernel mptcp key).
 */
static int extract_and_set_kernel_key(
		struct packet *live_packet)
{

	struct tcp_option* mpcap_opt =
			get_tcp_option(live_packet, TCPOPT_MPTCP);

	if(!mpcap_opt)
		return STATUS_ERR;

	//Check if kernel key hasn't been specified by user in script
	char *var_name;
	if(!queue_front(&mp_state.vars_queue, (void**)&var_name)){
		struct mp_var *var = find_mp_var(var_name);
		if(var && var->mptcp_subtype == MP_CAPABLE_SUBTYPE &&
				var->mp_capable_info.script_defined)
			set_kernel_key(*(u64*)var->value);
	}

	if(!mp_state.kernel_key_set){

		//Set found kernel key
		set_kernel_key(mpcap_opt->data.mp_capable.syn.key);
		//Set front queue variable name to refer to kernel key
		char *var_name;
		if(queue_front(&mp_state.vars_queue, (void**)&var_name)){
			return STATUS_ERR;
		}
		add_mp_var_key(var_name, &mp_state.kernel_key);
	}

	return STATUS_OK;
}

/**
 * Insert appropriate key in mp_capable mptcp option.
 */
int mptcp_subtype_mp_capable(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *tcp_opt_to_modify,
		unsigned direction)
{
	int error;
	// Syn packet, packetdril -> kernel
	if(tcp_opt_to_modify->length == TCPOLEN_MP_CAPABLE_SYN &&
			direction == DIRECTION_INBOUND &&
			!packet_to_modify->tcp->ack){
		error = mptcp_gen_key();
		error = mptcp_set_mp_cap_syn_key(tcp_opt_to_modify) || error;
	}
	// Syn and Syn_ack kernel->packetdrill
	else if(tcp_opt_to_modify->length == TCPOLEN_MP_CAPABLE_SYN &&
			direction == DIRECTION_OUTBOUND){
		error = extract_and_set_kernel_key(live_packet);
		error = mptcp_set_mp_cap_syn_key(tcp_opt_to_modify);
		mp_state.remote_ssn++;
	}
	// Third (ack) packet in three-hand shake
	else if(tcp_opt_to_modify->length == TCPOLEN_MP_CAPABLE ){
		error = mptcp_set_mp_cap_keys(tcp_opt_to_modify);
		// Automatically put the idsn tokens
		mp_state.idsn = sha1_least_64bits(mp_state.packetdrill_key);
		mp_state.remote_idsn = sha1_least_64bits(mp_state.kernel_key);

		if(direction == DIRECTION_INBOUND)
			new_subflow_inbound(packet_to_modify);
		else if(direction == DIRECTION_OUTBOUND)
			new_subflow_outbound(packet_to_modify);
		else
			return STATUS_ERR;
	}
	// SYN_ACK, packetdrill->kernel
	else if(tcp_opt_to_modify->length == TCPOLEN_MP_CAPABLE_SYN &&
			direction == DIRECTION_INBOUND &&
			packet_to_modify->tcp->ack){
		error = mptcp_gen_key();
		error = mptcp_set_mp_cap_syn_key(tcp_opt_to_modify) || error;
	}

	else{
		return STATUS_ERR;
	}
	return error;
}

/**
 * Set appropriate receiver token value in tcp_option.
 *
 */
static void mp_join_syn_rcv_token(struct tcp_option *tcp_opt_to_modify,
		struct mp_join_info *mp_join_script_info,
		unsigned direction)
{
	if(mp_join_script_info->syn_or_syn_ack.is_script_defined){

		if(mp_join_script_info->syn_or_syn_ack.is_var){
			struct mp_var *var = find_mp_var(mp_join_script_info->syn_or_syn_ack.var);
			tcp_opt_to_modify->data.mp_join.syn.no_ack.receiver_token =
					htonl(sha1_least_32bits(*(u64*)var->value));
		}
		else{
			tcp_opt_to_modify->data.mp_join.syn.no_ack.receiver_token =
					htonl(mp_join_script_info->syn_or_syn_ack.hash);
		}
	}
	else if(direction == DIRECTION_INBOUND){
		tcp_opt_to_modify->data.mp_join.syn.no_ack.receiver_token =
				htonl(sha1_least_32bits(mp_state.kernel_key));
	}
	else if(direction == DIRECTION_OUTBOUND){
		tcp_opt_to_modify->data.mp_join.syn.no_ack.receiver_token =
				htonl(sha1_least_32bits(mp_state.packetdrill_key));
	}
}

static void mp_join_syn_address_id(struct tcp_option *tcp_opt_to_modify,
		struct mp_join_info *mp_join_script_info,
		struct mp_subflow *subflow,
		unsigned direction)
{
	if(mp_join_script_info->syn_or_syn_ack.address_id_script_defined){
		u8 script_addr_id = mp_join_script_info->syn_or_syn_ack.address_id;
		if(direction == DIRECTION_INBOUND )
			subflow->packetdrill_addr_id = script_addr_id;
		else
			subflow->kernel_addr_id = script_addr_id;
	}
	if(direction == DIRECTION_INBOUND){
		tcp_opt_to_modify->data.mp_join.syn.address_id =
				subflow->packetdrill_addr_id;
	}
	else if(direction == DIRECTION_OUTBOUND){
		tcp_opt_to_modify->data.mp_join.syn.address_id =
				subflow->kernel_addr_id;
	}
}

static void mp_join_syn_rand(struct tcp_option *tcp_opt_to_modify,
		struct mp_join_info *mp_join_script_info,
		struct mp_subflow *subflow,
		unsigned direction)
{
	//Set sender random number value
	if(mp_join_script_info->syn_or_syn_ack.rand_script_defined){
		u32 script_rand = mp_join_script_info->syn_or_syn_ack.rand;
		if(direction == DIRECTION_INBOUND)
			subflow->packetdrill_rand_nbr = script_rand;
		else
			subflow->kernel_rand_nbr = script_rand;
	}
	if(direction == DIRECTION_INBOUND){
		tcp_opt_to_modify->data.mp_join.syn.no_ack.sender_random_number =
				subflow->packetdrill_rand_nbr;
	}
	else if(direction == DIRECTION_OUTBOUND){
		tcp_opt_to_modify->data.mp_join.syn.no_ack.sender_random_number =
				htonl(subflow->kernel_rand_nbr);
	}
}

/**
 * Manage the case when packetdrill send a mp_join_syn to the kernel.
 *
 */
static int mp_join_syn(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *tcp_opt_to_modify,
		struct mp_join_info *mp_join_script_info,
		unsigned direction)
{
	struct mp_subflow *subflow;
	if(direction == DIRECTION_INBOUND)
		subflow = new_subflow_inbound(packet_to_modify);
	else if(direction == DIRECTION_OUTBOUND)
		subflow = new_subflow_outbound(live_packet);
	if(!subflow)
		return STATUS_ERR;

	mp_join_syn_rcv_token(tcp_opt_to_modify, mp_join_script_info, direction);
	mp_join_syn_rand(tcp_opt_to_modify,
			mp_join_script_info,
			subflow,
			direction);
	mp_join_syn_address_id(tcp_opt_to_modify,
			mp_join_script_info,
			subflow,
			direction);

	return STATUS_OK;
}

void mp_join_syn_ack_sender_hmac(struct tcp_option *tcp_opt_to_modify,
		u64 key1, u64 key2, u32 msg1, u32 msg2)
{
	//Build key for HMAC-SHA1
	unsigned char hmac_key[16];
	unsigned long *key_a = (unsigned long*)hmac_key;
	unsigned long *key_b = (unsigned long*)&(hmac_key[8]);
	*key_a = key1;
	*key_b = key2;

	//Build message for HMAC-SHA1
	u32 msg[2];
	msg[0] = msg1;
	msg[1] = msg2;
	tcp_opt_to_modify->data.mp_join.syn.ack.sender_hmac =
			htobe64(hmac_sha1_truncat_64(hmac_key,
					16,
					(char*)msg,
					8));
}

static int mp_join_syn_ack(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *tcp_opt_to_modify,
		struct mp_join_info *mp_join_script_info,
		unsigned direction)
{
	if(direction == DIRECTION_INBOUND){
		struct mp_subflow *subflow =
				find_subflow_matching_inbound_packet(packet_to_modify);

		if(!subflow)
			return STATUS_ERR;

		subflow->packetdrill_rand_nbr = generate_32();

		mp_join_syn_address_id(tcp_opt_to_modify,
				mp_join_script_info,
				subflow,
				direction);
		mp_state.last_packetdrill_addr_id++;

		if(mp_join_script_info->syn_or_syn_ack.rand_script_defined)
			subflow->packetdrill_rand_nbr =
					mp_join_script_info->syn_or_syn_ack.rand;

		tcp_opt_to_modify->data.mp_join.syn.ack.sender_random_number =
				htonl(subflow->packetdrill_rand_nbr);

		if(mp_join_script_info->syn_or_syn_ack.is_script_defined){
			if(mp_join_script_info->syn_or_syn_ack.is_var){
				struct mp_var *var =
						find_mp_var(mp_join_script_info->syn_or_syn_ack.var);
				struct mp_var *var2 =
						find_mp_var(mp_join_script_info->syn_or_syn_ack.var2);
				mp_join_syn_ack_sender_hmac(tcp_opt_to_modify,
									*(u64*)var->value,
									*(u64*)var2->value,
									subflow->packetdrill_rand_nbr,
									subflow->kernel_rand_nbr);

			}
		}
		else{
			mp_join_syn_ack_sender_hmac(tcp_opt_to_modify,
					mp_state.packetdrill_key,
					mp_state.kernel_key,
					subflow->packetdrill_rand_nbr,
					subflow->kernel_rand_nbr);
		}
	}

	else if(direction == DIRECTION_OUTBOUND){
		struct mp_subflow *subflow =
				find_subflow_matching_outbound_packet(live_packet);
		struct tcp_option *live_mp_join =
				get_tcp_option(live_packet, TCPOPT_MPTCP);

		if(!subflow || !live_mp_join)
			return STATUS_ERR;

		//Update mptcp packetdrill state
		subflow->kernel_addr_id =
				live_mp_join->data.mp_join.syn.address_id;
		subflow->kernel_rand_nbr =
				live_mp_join->data.mp_join.syn.ack.sender_random_number;

		//Build key for HMAC-SHA1
		unsigned char hmac_key[16];
		unsigned long *key_b = (unsigned long*)hmac_key;
		unsigned long *key_a = (unsigned long*)&(hmac_key[8]);
		*key_b = mp_state.kernel_key;
		*key_a = mp_state.packetdrill_key;

		//Build message for HMAC-SHA1
		unsigned msg[2];
		msg[0] = subflow->kernel_rand_nbr;
		msg[1] = subflow->packetdrill_rand_nbr;

		//Update script packet mp_join option fields
		tcp_opt_to_modify->data.mp_join.syn.address_id =
				live_mp_join->data.mp_join.syn.address_id;
		tcp_opt_to_modify->data.mp_join.syn.ack.sender_random_number =
				live_mp_join->data.mp_join.syn.ack.sender_random_number;
		tcp_opt_to_modify->data.mp_join.syn.ack.sender_hmac =
				hmac_sha1_truncat_64(hmac_key, 16, (char*)msg, 8);
	}
	return STATUS_OK;
}
/**
 * Update mptcp subflows state according to sent/sniffed mp_join packets.
 * Insert appropriate values retrieved from this up-to-date state in inbound
 * and outbound packets.
 */
int mptcp_subtype_mp_join(struct packet *packet_to_modify,
						struct packet *live_packet,
						struct tcp_option *tcp_opt_to_modify,
						unsigned direction)
{
	struct mp_join_info *mp_join_script_info;
	if(queue_dequeue(&mp_state.vars_queue, (void**)&mp_join_script_info))
		return STATUS_ERR;

	if(direction == DIRECTION_INBOUND &&
			!packet_to_modify->tcp->ack &&
			packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_SYN){

		mp_join_syn(packet_to_modify,
				live_packet,
				tcp_opt_to_modify,
				mp_join_script_info,
				DIRECTION_INBOUND);
	}
	else if(direction == DIRECTION_OUTBOUND &&
			packet_to_modify->tcp->ack &&
			packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_SYN_ACK){

		struct mp_subflow *subflow =
				find_subflow_matching_outbound_packet(live_packet);
		struct tcp_option *live_mp_join =
				get_tcp_option(live_packet, TCPOPT_MPTCP);

		if(!subflow || !live_mp_join)
			return STATUS_ERR;

		//Update mptcp packetdrill state
		subflow->kernel_addr_id =
				live_mp_join->data.mp_join.syn.address_id;
		subflow->kernel_rand_nbr =
				live_mp_join->data.mp_join.syn.ack.sender_random_number;

		//Update script packet mp_join option fields
		tcp_opt_to_modify->data.mp_join.syn.address_id =
				live_mp_join->data.mp_join.syn.address_id;
		tcp_opt_to_modify->data.mp_join.syn.ack.sender_random_number =
				live_mp_join->data.mp_join.syn.ack.sender_random_number;

		//Build key for HMAC-SHA1
		u64 loc_key = mp_state.packetdrill_key;
		u64 rem_key = mp_state.kernel_key;
		u32 loc_nonce = subflow->packetdrill_rand_nbr;
		u32 rem_nonce = live_mp_join->data.mp_join.syn.ack.sender_random_number;

		// return value
		u8 mptcp_hash_mac[20];
		mptcp_hmac_sha1(
				(u8*)&rem_key,
				(u8*)&loc_key,
				(u8*)&rem_nonce,
				(u8*)&loc_nonce,
				(u32*)mptcp_hash_mac );

//		u64 live_hmac = live_mp_join->data.mp_join.syn.ack.sender_hmac;
//		printf("822: %llu == %llu\n", live_hmac, *(u64*)mptcp_hash_mac );

		tcp_opt_to_modify->data.mp_join.syn.ack.sender_hmac = *(u64*)mptcp_hash_mac;
	}
	//mp_join ack
	else if(direction == DIRECTION_INBOUND &&
			packet_to_modify->tcp->ack &&
			!packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_ACK){
		struct mp_subflow *subflow = find_subflow_matching_inbound_packet(packet_to_modify);
		if(!subflow)
			return STATUS_ERR;

		//Build key for HMAC-SHA1
		u64 loc_key = mp_state.packetdrill_key;
		u64 rem_key = mp_state.kernel_key;
		u32 loc_nonce = subflow->packetdrill_rand_nbr;
		u32 rem_nonce = subflow->kernel_rand_nbr;

		// return value
		u8 mptcp_hash_mac[20];
		mptcp_hmac_sha1(
				(u8*)&loc_key,
				(u8*)&rem_key,
				(u8*)&loc_nonce,
				(u8*)&rem_nonce,
				(u32*)mptcp_hash_mac );

		memcpy(tcp_opt_to_modify->data.mp_join.no_syn.sender_hmac,
				mptcp_hash_mac,
				20);
	}

	else if(direction == DIRECTION_OUTBOUND &&
			!packet_to_modify->tcp->ack &&
			packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_SYN){

		mp_join_syn(packet_to_modify,
				live_packet,
				tcp_opt_to_modify,
				mp_join_script_info,
				DIRECTION_OUTBOUND);
	}

	else if(direction == DIRECTION_INBOUND &&
			packet_to_modify->tcp->ack &&
			packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_SYN_ACK){

		mp_join_syn_ack(packet_to_modify,
				live_packet,
				tcp_opt_to_modify,
				mp_join_script_info,
				DIRECTION_INBOUND);
	}

	else if(direction == DIRECTION_OUTBOUND &&
			packet_to_modify->tcp->ack &&
			!packet_to_modify->tcp->syn &&
			tcp_opt_to_modify->length == TCPOLEN_MP_JOIN_ACK){

		struct mp_subflow *subflow =
				find_subflow_matching_outbound_packet(packet_to_modify);

		if(!subflow)
			return STATUS_ERR;

		//Build key for HMAC-SHA1
		u64 loc_key = mp_state.packetdrill_key;
		u64 rem_key = mp_state.kernel_key;
		u32 loc_nonce = subflow->packetdrill_rand_nbr;
		u32 rem_nonce = subflow->kernel_rand_nbr;

		// return value
		u8 mptcp_hash_mac[20];
		mptcp_hmac_sha1(
				(u8*)&rem_key,
				(u8*)&loc_key,
				(u8*)&rem_nonce,
				(u8*)&loc_nonce,
				(u32*)mptcp_hash_mac );

		memcpy(tcp_opt_to_modify->data.mp_join.no_syn.sender_hmac,
				mptcp_hash_mac, 20);
	}
	else{
		return STATUS_ERR;
	}
	return STATUS_OK;
}

//Compute tcp payload length
u16 get_tcp_payload_size(struct packet *packet){
	u16 packet_total_length = packet->ip_bytes;
	u16 tcp_header_length = packet->tcp->doff*4;
	u16 ip_header_length = packet->ipv4->ihl*8;
	u16 tcp_header_wo_options = 20;
	return (packet_total_length-ip_header_length-
			(tcp_header_length-tcp_header_wo_options));
}
u32 get_sum_ssn(){
	struct mp_subflow *mp_sub = mp_state.subflows;
	u32 total_length = 1; // first subflow has already one packet sent
	while(mp_sub != NULL){
		total_length += mp_sub->ssn -1;
		mp_sub = mp_sub->next;
	}
	return total_length;
}

u16 get_tcp_header_length(struct packet *packet){
	return  packet->tcp->doff*4 + 20; // tcp_header_wo_options = 20
}

/**
 *  It will parse an inbound packet and modify the script packet 
 *  in order to correspond with the scripted tests.
 */
int dss_inbound_parser(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *dss_opt_script){

	struct mp_subflow *subflow = find_subflow_matching_inbound_packet(packet_to_modify);

	u16 tcp_payload_length = (u16)packet_payload_len(packet_to_modify);

	struct tcp_option* dss_opt_live = get_tcp_option(live_packet, TCPOPT_MPTCP);
	// if a packet is going from packetdrill with DSN and DACK to kernel
	if(dss_opt_script->data.dss.flag_M && dss_opt_script->data.dss.flag_A){

		u32 bytes_sent_on_all_ssn = get_sum_ssn();
		// if dsn4 and dack4
		if(!dss_opt_script->data.dss.flag_m && !dss_opt_script->data.dss.flag_a){

			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+2);

			// put information in script packet automatically
			if(dss_opt_script->data.dss.dack_dsn.dack.dack4 == UNDEFINED)
				dack_live->dack4 = htonl(mp_state.remote_idsn + mp_state.remote_ssn + mp_state.remote_last_pkt_length);
			else if(dss_opt_script->data.dss.dack_dsn.dack.dack4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dack_live->dack4 = htonl(sha1_least_64bits(*key)+ additional_val);
			}

			if(dss_opt_script->data.dss.dack_dsn.dsn.dsn4 == UNDEFINED){
				dsn_live->dsn4 = htonl(mp_state.idsn + bytes_sent_on_all_ssn); //subflow->ssn);
			}else if(dss_opt_script->data.dss.dack_dsn.dsn.dsn4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dsn_live->dsn4 = htonl(sha1_least_64bits(*key) + additional_val);
			}
			if(dss_opt_script->length == TCPOLEN_DSS_DACK4_DSN4){
				//Compute checksum
				struct {
					u64 dsn;
					u32 ssn;
					u16 dll;
					u16 zeros;
				} __packed buff_chk;

				buff_chk.dsn = mp_state.idsn + bytes_sent_on_all_ssn; //subflow->ssn;
				buff_chk.ssn = subflow->ssn;
				buff_chk.dll = (u16)tcp_payload_length;
				buff_chk.zeros = (u16)0;

				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+1;	// w_cs == ssn
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
				*(dll_first+1) = htons(checksum_dss((u16*)&buff_chk, sizeof(buff_chk)));
			}else{
				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+1;	// w_cs == ssn (== dsn_live + 1 )
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
			}

		// DSN4 & DACK8
		}else if(!dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a){
			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+3);

			// put information in script packet
			if(dss_opt_script->data.dss.dack_dsn.dack.dack8 == UNDEFINED)
				dack_live->dack8 = htobe64(mp_state.remote_idsn + mp_state.remote_ssn);
			else if(dss_opt_script->data.dss.dack_dsn.dack.dack8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dack_live->dack8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}
			if(dss_opt_script->data.dss.dack_dsn.dsn.dsn4 == UNDEFINED)
				dsn_live->dsn4 = htonl( mp_state.idsn + bytes_sent_on_all_ssn); //subflow->ssn);
			else if(dss_opt_script->data.dss.dack_dsn.dsn.dsn4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dsn_live->dsn4 = htonl(sha1_least_64bits(*key)+ additional_val);
			}

			if(dss_opt_script->length == TCPOLEN_DSS_DACK8_DSN4){
				//Compute checksum
				struct {
					u64 dsn;
					u32 ssn;
					u16 dll;
					u16 zeros;
				} __packed buff_chk;

				buff_chk.dsn = mp_state.idsn + bytes_sent_on_all_ssn; //subflow->ssn;
				buff_chk.ssn = subflow->ssn;
				buff_chk.dll = (u16)tcp_payload_length;
				buff_chk.zeros = (u16)0;

				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+1;	// w_cs == ssn
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
				*(dll_first+1) = htons(checksum_dss((u16*)&buff_chk, sizeof(buff_chk)));
			}else{
				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+1;	// w_cs == ssn (== dsn_live + 1 )
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
			}


		// DSN8 & DACK4
		}else if(dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a){
			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+2);

			// put information in script packet
			if(dss_opt_script->data.dss.dack_dsn.dack.dack4 == UNDEFINED)
				dack_live->dack4 = htobe32(mp_state.remote_idsn + mp_state.remote_ssn);
			else if(dss_opt_script->data.dss.dack_dsn.dack.dack4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dack_live->dack4 = htonl(sha1_least_64bits(*key) + additional_val);
			}

			if(dss_opt_script->data.dss.dack_dsn.dsn.dsn8 == UNDEFINED)
				dsn_live->dsn8 = htobe64(mp_state.idsn + bytes_sent_on_all_ssn); //subflow->ssn);
			else if(dss_opt_script->data.dss.dack_dsn.dsn.dsn8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dsn_live->dsn8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}

			if(dss_opt_script->length == TCPOLEN_DSS_DACK4_DSN8){
				//Compute checksum
				struct {
					u64 dsn;
					u32 ssn;
					u16 dll;
					u16 zeros;
				} __packed buff_chk;

				buff_chk.dsn = mp_state.idsn + bytes_sent_on_all_ssn; //subflow->ssn;
				buff_chk.ssn = subflow->ssn;
				buff_chk.dll = (u16)tcp_payload_length;
				buff_chk.zeros = (u16)0;

				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+2;	// w_cs == ssn
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
				*(dll_first+1) = htons(checksum_dss((u16*)&buff_chk, sizeof(buff_chk)));
			}else{
				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+2;	// w_cs == ssn (== dsn_live + 1 )
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
			}
		// DSN8 & DACK8
		}else if(dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a){
			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+3);

			// put information in script packet
			if(dss_opt_script->data.dss.dack_dsn.dack.dack8 == UNDEFINED)
				dack_live->dack8 = htobe64(mp_state.remote_idsn + mp_state.remote_ssn);
			else if(dss_opt_script->data.dss.dack_dsn.dack.dack8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dack_live->dack8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}
			if(dss_opt_script->data.dss.dack_dsn.dsn.dsn8 == UNDEFINED)
				dsn_live->dsn8 = htobe64(mp_state.idsn + bytes_sent_on_all_ssn); //subflow->ssn);
			else if(dss_opt_script->data.dss.dack_dsn.dsn.dsn8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dsn_live->dsn8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}
			if(dss_opt_script->length == TCPOLEN_DSS_DACK8_DSN8){
				//Compute checksum
				struct {
					u64 dsn;
					u32 ssn;
					u16 dll;
					u16 zeros;
				} __packed buff_chk;

				buff_chk.dsn = mp_state.idsn + bytes_sent_on_all_ssn; //subflow->ssn;
				buff_chk.ssn = subflow->ssn;
				buff_chk.dll = (u16)tcp_payload_length;
				buff_chk.zeros = (u16)0;

				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+2;	// w_cs == ssn
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
				*(dll_first+1) = htons(checksum_dss((u16*)&buff_chk, sizeof(buff_chk)));
			}else{
				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+2;	// w_cs == ssn (== dsn_live + 1 )
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
			}
		}
	// IF DSN only
	}else if(dss_opt_script->data.dss.flag_M){
		struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+1);
		u32 bytes_sent_on_all_ssn = get_sum_ssn();
		//DSN4
		if(!dss_opt_script->data.dss.flag_m){
			// get original information from live_packet

			if(dss_opt_script->data.dss.dsn.dsn4 == UNDEFINED)
				dsn_live->dsn4 = htonl(mp_state.idsn + bytes_sent_on_all_ssn); //subflow->ssn);
			else if(dss_opt_script->data.dss.dsn.dsn4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dsn_live->dsn4 = htobe32(sha1_least_64bits(*key) + additional_val);
			}

			if(dss_opt_script->length == TCPOLEN_DSS_DSN4){
				//Compute checksum
				struct {
					u64 dsn;
					u32 ssn;
					u16 dll;
					u16 zeros;
				} __packed buff_chk;

				buff_chk.dsn = mp_state.idsn + bytes_sent_on_all_ssn; //subflow->ssn;
				buff_chk.ssn = subflow->ssn;
				buff_chk.dll = (u16)tcp_payload_length;
				buff_chk.zeros = (u16)0;

				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+1;	// w_cs == ssn
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
				*(dll_first+1) = htons(checksum_dss((u16*)&buff_chk, sizeof(buff_chk)));
			}else{
				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+1;	// w_cs == ssn (== dsn_live + 1 )
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
			}

		//DSN8
		}else{
			if(dss_opt_script->data.dss.dsn.dsn8 == UNDEFINED)
				dsn_live->dsn8 = htobe64(mp_state.idsn + bytes_sent_on_all_ssn); //subflow->ssn);
			else if(dss_opt_script->data.dss.dsn.dsn8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dsn_live->dsn8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}
			if(dss_opt_script->length == TCPOLEN_DSS_DSN8){
				//Compute checksum
				struct {
					u64 dsn;
					u32 ssn;
					u16 dll;
					u16 zeros;
				} __packed buff_chk;

				buff_chk.dsn = mp_state.idsn + bytes_sent_on_all_ssn; //subflow->ssn;
				buff_chk.ssn = subflow->ssn;
				buff_chk.dll = (u16)tcp_payload_length;
				buff_chk.zeros = (u16)0;

				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+2;	// w_cs == ssn
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
				*(dll_first+1) = htons(checksum_dss((u16*)&buff_chk, sizeof(buff_chk)));
			}else{
				// ssn + dll + checksum
				u32* w_cs = (u32*)dsn_live+2;	// w_cs == ssn (== dsn_live + 1 )
				*w_cs = htonl(subflow->ssn);
				u16 *dll_first = (u16*)(w_cs+1);// w_cs + 1 == dll & chk
				*(dll_first) = htons(tcp_payload_length);
			}
		}
	}
	// IF ACK only
	else if(dss_opt_script->data.dss.flag_A){
		// dack4
		if(!dss_opt_script->data.dss.flag_a){
			if(dss_opt_script->data.dss.dack.dack4==UNDEFINED){
				dss_opt_script->data.dss.dack.dack4 = ntohl((u32)(mp_state.remote_idsn + mp_state.remote_ssn + mp_state.remote_last_pkt_length));
			}else if(dss_opt_script->data.dss.dack.dack4==SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack.dack4 = htonl(sha1_least_64bits(*key) + additional_val);
			}else{
				return STATUS_ERR;
			}
		}
	}
	subflow->ssn += tcp_payload_length;
	return STATUS_OK;
}

int dss_outbound_parser(struct packet *packet_to_modify,
		struct packet *live_packet,
		struct tcp_option *dss_opt_script){
	
	struct tcp_option* dss_opt_live = get_mptcp_option(live_packet, DSS_SUBTYPE);
	
	// if a packet is coming from kernel with DSN and DACK
	if(dss_opt_script->data.dss.flag_M && dss_opt_script->data.dss.flag_A){

		// DSN4 & DACK4
		if(!dss_opt_script->data.dss.flag_m && !dss_opt_script->data.dss.flag_a){
			if(!(!dss_opt_live->data.dss.flag_m && !dss_opt_live->data.dss.flag_a))
				return STATUS_ERR;

			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+2);
			
			// put information in script packet
			if(dss_opt_script->data.dss.dack_dsn.dack.dack4 == UNDEFINED){
				dss_opt_script->data.dss.dack_dsn.dack.dack4 = dack_live->dack4;
			}else if(dss_opt_script->data.dss.dack_dsn.dack.dack4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack_dsn.dack.dack4 = htonl(sha1_least_64bits(*key) + additional_val);
			}

			// get ssn, dll, and checksum from live_packet 
			u32 ssn 	= *((u32*)dsn_live + 1);
			u32 dll_chk = (u32)*((u32*)dsn_live + 2);
			u16 dll 	= (u16)dll_chk;
//			mp_state.last_dsn_rcvd = ntohl(dsn_live->dsn4);
			mp_state.remote_last_pkt_length = ntohs(dll);
			mp_state.remote_ssn = ntohl(ssn);
			u32 *script_dsn4 	= (u32*)dss_opt_script+2;   // jump over 64 bits to reach the dsn
			//Set dsn being value specified in script 
			if(dss_opt_script->data.dss.dack_dsn.dsn.dsn4==UNDEFINED)
				*script_dsn4 	= dsn_live->dsn4;
			else if(dss_opt_script->data.dss.dack_dsn.dsn.dsn4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key 			= find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*script_dsn4 = htobe32(sha1_least_64bits(*key) + additional_val);
			}
			// put ssn, dll, chk in script_packet
			u32 *script_ssn 		= script_dsn4 + 1;
			*script_ssn 			= ssn;
			u32 *script_dll_chk 	= script_ssn + 1;
			*script_dll_chk 		= dll_chk;

		// DSN4 & DACK8
		}else if(!dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a){
			if(!(!dss_opt_live->data.dss.flag_m && dss_opt_live->data.dss.flag_a))
				return STATUS_ERR;
			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1); // to jump over  Kind | Length | Subtype | flags = u32
			struct dsn *dsn_live 	= (struct dsn*)((u64*)dack_live+1); // dsn = 64 bits
			
			// put information in script packet
			if(dss_opt_script->data.dss.dack_dsn.dack.dack8 == UNDEFINED)
				dss_opt_script->data.dss.dack_dsn.dack.dack8 =  dack_live->dack8; // be64toh
			else if(dss_opt_script->data.dss.dack_dsn.dack.dack8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack_dsn.dack.dack8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}
			u32 *script_dsn4 	= (u32*)dss_opt_script+3;
			
			//Set dsn being value specified in script test
			if(dss_opt_script->data.dss.dack_dsn.dsn.dsn4==UNDEFINED)
				*script_dsn4 	= dsn_live->dsn4;
			else if(dss_opt_script->data.dss.dack_dsn.dsn.dsn4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*script_dsn4 = htobe32(sha1_least_64bits(*key) + additional_val);
			}
			// get ssn, dll, and checksum from live_packet 
			u32 ssn = *((u32*)dsn_live + 1);
			u32 dll_chk = (u32)*((u32*)dsn_live + 2);
			u16 dll = (u16)dll_chk;
//			u16 chk = dll_chk >> 16;
			
			// put ssn, dll, chk in script_packet
			u32 *script_ssn 		= script_dsn4 + 1;
			*script_ssn 			= ssn;
			u32 *script_dll_chk 	= script_ssn + 1;
			*script_dll_chk 		= dll_chk;
			
//			mp_state.last_dsn_rcvd = ntohl(dsn_live->dsn4);
			mp_state.remote_last_pkt_length = ntohs(dll);
			mp_state.remote_ssn = ntohl(ssn);

//			printf("dack8: %u, dsn4: %u", ntohl(dack_live->dack8), ntohl(dsn_live->dsn4)); // OK
//			printf(", ssn: %u, dll: %u, chk: %u\n", ntohl(ssn), ntohs(dll), ntohs(chk));

			// DSN8 & DACK4
		}else if(dss_opt_script->data.dss.flag_m && !dss_opt_script->data.dss.flag_a){
			if(!(dss_opt_live->data.dss.flag_m && !dss_opt_live->data.dss.flag_a))
				return STATUS_ERR;
			
			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*)((u32*)dack_live+1);
			
			// put information in script packet
			if(dss_opt_script->data.dss.dack_dsn.dack.dack4 == UNDEFINED)
				dss_opt_script->data.dss.dack_dsn.dack.dack4 = dack_live->dack4;
			else if(dss_opt_script->data.dss.dack_dsn.dack.dack4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack_dsn.dack.dack4 = htobe32(sha1_least_64bits(*key) + additional_val);
			}
			// get ssn, dll, and checksum from live_packet 
			u32 ssn 	= *((u64*)dsn_live + 1);
			u32 dll_chk = (u32)*((u32*)dsn_live + 2);
			u16 dll 	= (u16)dll_chk;
//			u16 chk 	= dll_chk >> 16;
			
			u64 *script_dsn8 	= (u64*)((u32*)dss_opt_script+2);   
			
			//Set dsn being value specified in script 
			if(dss_opt_script->data.dss.dack_dsn.dsn.dsn8 == UNDEFINED)
				*script_dsn8 	= dsn_live->dsn8;
			else if(dss_opt_script->data.dss.dack_dsn.dsn.dsn8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*script_dsn8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}
			// put ssn, dll, chk in script_packet
			u32 *script_ssn 		= (u32*)((u64*)script_dsn8 + 1);
			*script_ssn 			= ssn;
			u32 *script_dll_chk 	= script_ssn + 1;
			*script_dll_chk 		= dll_chk;
//			mp_state.last_dsn_rcvd = ntohl(dsn_live->dsn8);
			mp_state.remote_last_pkt_length = ntohs(dll);
			mp_state.remote_ssn = ntohl(ssn);
			
//			printf("dack4: %u, dsn8: %u", ntohl(dack_live->dack4), ntohl(dsn_live->dsn8)); // OK
//			printf(", ssn: %u, dll: %u, chk: %u\n", ntohl(ssn), ntohs(dll), ntohs(chk));

		// DSN8 & DACK8
		}else if(dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a){
			if(!(dss_opt_script->data.dss.flag_m && dss_opt_script->data.dss.flag_a))
				return STATUS_ERR;
			
			// get original information from live_packet
			struct dack *dack_live	= (struct dack*)((u32*)dss_opt_live+1);
			struct dsn *dsn_live 	= (struct dsn*)((u32*)dack_live+2);
			
			// put information in script packet
			if(dss_opt_script->data.dss.dack_dsn.dack.dack8 == UNDEFINED)
				dss_opt_script->data.dss.dack_dsn.dack.dack8 = dack_live->dack8;
			else if(dss_opt_script->data.dss.dack_dsn.dack.dack8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack_dsn.dack.dack8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}
			// get ssn, dll, and checksum from live_packet 
			u32 ssn 	= (u32)*((u32*)dsn_live + 2);
			u32 dll_chk = (u32)*((u32*)dsn_live + 3);
			u16 dll 	= (u16)dll_chk;
//			u16 chk 	= dll_chk >> 16;
			
			u64 *script_dsn8 	= (u64*)((u32*)dss_opt_script+2);   
			
			//Set dsn being value specified in script 
			if(dss_opt_script->data.dss.dack_dsn.dsn.dsn8==UNDEFINED)
				*script_dsn8 		= dsn_live->dsn8;
			else if(dss_opt_script->data.dss.dack_dsn.dsn.dsn8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				*script_dsn8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}
			// put ssn, dll, chk in script_packet
			u32 *script_ssn 		= (u32*)((u64*)script_dsn8 + 1);
			*script_ssn 			= ssn;
			u32 *script_dll_chk 	= script_ssn + 1;
			*script_dll_chk 		= dll_chk;

			mp_state.remote_last_pkt_length = ntohs(dll);
			mp_state.remote_ssn = ntohl(ssn);
//			printf("dack8: %llu, dsn8: %llu", (u64)be64toh(dack_live->dack8), (u64)be64toh(dsn_live->dsn8));
//			printf(", ssn: %u, dll: %u, chk: %u\n", ntohl(ssn), ntohs(dll), ntohs(chk));

		}else{
			// It means we have a difference of flags about what we waited for
			return STATUS_ERR;
		}
	
	// Only DSN is in the packet
	}else if(dss_opt_script->data.dss.flag_M ){ // DSS
		if(!dss_opt_script->data.dss.flag_M)
			return STATUS_ERR;
		
		// get original dsn from live_packet
		struct dsn *dsn_live 	= (struct dsn*)((u32*)dss_opt_live+1);
		
		// if DSN is 8 octets
		if(dss_opt_script->data.dss.flag_m){
			
			// get ssn, dll, and checksum from live_packet 
			u32 ssn 	= *((u32*)dsn_live + 1);
			u32 dll_chk = (u32)*((u32*)dsn_live + 3);
			u16 dll 	= (u16)dll_chk;
			u16 chk 	= dll_chk >> 16;
			
			// if dsn8 is not given in the script, we'll put it automatically
			if(dss_opt_script->data.dss.dsn.dsn8 == UNDEFINED)
				dss_opt_script->data.dss.dsn.dsn8 = dsn_live->dsn8; //htobe64
			else if(dss_opt_script->data.dss.dsn.dsn8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dsn.dsn8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}
			if(dss_opt_script->length == TCPOLEN_DSS_DSN8){
				dss_opt_script->data.dss.dsn.w_cs.dll =	dll;
				dss_opt_script->data.dss.dsn.w_cs.ssn = ssn;
				dss_opt_script->data.dss.dsn.w_cs.checksum = chk;
			}else{
				dss_opt_script->data.dss.dsn.wo_cs.dll =	dll;
				dss_opt_script->data.dss.dsn.wo_cs.ssn = ssn;
			}
			mp_state.remote_last_pkt_length = ntohs(dll);
			mp_state.remote_ssn = ntohl(ssn);
		}
		// if DSN is 4 octets
		else {
			// get ssn, dll, and checksum from live_packet 
			u32 ssn 	= *((u32*)dsn_live + 1);
			u32 dll_chk = (u32)*((u32*)dsn_live + 2);
			u16 dll 	= (u16)dll_chk;
//			u16 chk 	= dll_chk >> 16;
			
			// if dsn8 is not given in the script, we'll put it automatically
			if(dss_opt_script->data.dss.dsn.dsn4 == UNDEFINED)
				dss_opt_script->data.dss.dsn.dsn4 = dsn_live->dsn4;
			else if(dss_opt_script->data.dss.dsn.dsn4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dsn.dsn4 = htobe32(sha1_least_64bits(*key) + additional_val);
			}
			u32 *script_dsn4 	= (u32*)dss_opt_script+3;
			// put ssn, dll, chk in script_packet
			u32 *script_ssn 		= (u32*)((u32*)script_dsn4 + 1);
			*script_ssn 			= ssn;
			u32 *script_dll_chk 	= script_ssn + 1;
			*script_dll_chk 		= dll_chk;
			mp_state.remote_last_pkt_length = ntohs(dll);
			mp_state.remote_ssn = ntohl(ssn);
		}

	// if it's DACK only from kernel, need to save it 
	}else if(dss_opt_script->data.dss.flag_A ){
		if(!dss_opt_script->data.dss.flag_A)
			return STATUS_ERR;
		
		// get original dack from live_packet
		struct dack *dack_live 	= (struct dack*)((u32*)dss_opt_live+1);
		
		// if DACK is 8 octets
		if(dss_opt_script->data.dss.flag_a){
			
			// if dack8 is not given in the script, we'll put it automatically
			if(dss_opt_script->data.dss.dack.dack8 == UNDEFINED)
				dss_opt_script->data.dss.dack.dack8 = dack_live->dack8;
			else if(dss_opt_script->data.dss.dack.dack8 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack.dack8 = htobe64(sha1_least_64bits(*key) + additional_val);
			}
		}
		// if DACK is 4 octets
		else {
			// if dack4 is not given in the script, we'll put it automatically
			if(dss_opt_script->data.dss.dack.dack4 == UNDEFINED)
				dss_opt_script->data.dss.dack.dack4 = dack_live->dack4;
			else if(dss_opt_script->data.dss.dack.dack4==SCRIPT_DEFINED){
				u64 *key = find_next_key();
				if(!key)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack.dack4 = htobe32((u32)*key);
			}else if(dss_opt_script->data.dss.dack.dack4 == SCRIPT_DEFINED_TO_HASH_LSB){
				u64 additional_val 	= find_next_value();
				u64 *key = find_next_key();
				if(!key || additional_val==STATUS_ERR)
					return STATUS_ERR;
				dss_opt_script->data.dss.dack.dack4 = htobe32(sha1_least_64bits(*key) + additional_val);
			}
		}
	}else
		return STATUS_ERR;
	
	return STATUS_OK;
}


int mptcp_subtype_dss(struct packet *packet_to_modify,
						struct packet *live_packet,
						struct tcp_option *tcp_opt_to_modify,
						unsigned direction){
	int error = -1;
	// injecting a packet to kernel
	if(direction == DIRECTION_INBOUND){
		error = dss_inbound_parser(packet_to_modify, live_packet, tcp_opt_to_modify);
	}else if(direction == DIRECTION_OUTBOUND){
		error = dss_outbound_parser(packet_to_modify, live_packet, tcp_opt_to_modify);
	}
	if(error!=STATUS_OK)
		return STATUS_ERR;
	
	return STATUS_OK;
}

/**
 * Main function for managing mptcp packets. We have to insert appropriate
 * fields values for mptcp options according to previous state.
 *
 * Some of these values are generated randomly (packetdrill mptcp key,...)
 * others are sniffed from packets sent by the kernel (kernel mptcp key,...).
 * These values have to be inserted some mptcp script and live packets.
 */
int mptcp_insert_and_extract_opt_fields(struct packet *packet_to_modify,
		struct packet *live_packet, // could be the same as packet_to_modify
		unsigned direction)
{

	struct tcp_options_iterator tcp_opt_iter;
	struct tcp_option *tcp_opt_to_modify =
			tcp_options_begin(packet_to_modify, &tcp_opt_iter);
	int error;

	while(tcp_opt_to_modify != NULL){
		if(tcp_opt_to_modify->kind == TCPOPT_MPTCP){
			switch(tcp_opt_to_modify->data.mp_capable.subtype){

			case MP_CAPABLE_SUBTYPE:	// 00
				error = mptcp_subtype_mp_capable(packet_to_modify,
						live_packet,
						tcp_opt_to_modify,
						direction);
				break;

			case MP_JOIN_SUBTYPE:		//01
				error = mptcp_subtype_mp_join(packet_to_modify,
						live_packet,
						tcp_opt_to_modify,
						direction);
				break;

			case DSS_SUBTYPE:			//02
				error = mptcp_subtype_dss(packet_to_modify,
						live_packet,
						tcp_opt_to_modify,
						direction);
				break;
			case ADD_ADDR_SUBTYPE: 	//03 TODO
				printf("ADD_ADDR_SUBTYPE, todo\n");
				break;
			case REMOVE_ADDR_SUBTYPE:	// 04 TODO
				printf("REMOVE_ADDR_SUBTYPE, todo\n");
				break;
			case MP_PRIO_SUBTYPE: 		// 05 TODO
				printf("MP_PRIO_SUBTYPE, todo\n");
				break;
			case MP_FAIL_SUBTYPE: 		// 06 TODO
				printf("MP_FAIL_SUBTYPE, todo\n");
				break;
			case MP_FASTCLOSE_SUBTYPE:		// 07 TODO
				printf("MP_FASTCLOSE_SUBTYPE, todo\n");
				break;
			default:
				error =  STATUS_ERR;
				break;
			}

			if(error)
				return STATUS_ERR;

		}

		tcp_opt_to_modify = tcp_options_next(&tcp_opt_iter, NULL);
	}

	return STATUS_OK;
}
